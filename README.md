# Deploy
https://reykjavik-last-practicant-3.ya-praktikum.tech (Yandex Cloud - актуальная версия)
https://last-practicant.herokuapp.com/ (Heroku - старая версия, больше не обновляется)

# Сборка + БД (последовательность действий)
Перед началом разработки необходимо поднять контейнеры с БД. Это можно сделать следующим образом (из корневой директории проекта):
1) docker-compose up -d (поднять все контейнеры из docker-compose.yaml)
2) выключить контейнер lp-app (т.к. это наше приложение в контейнере, в нем нет нужды на время разработки, освобождаем порт)
3) выключить контейнер mongo (т.е. по сути пока не используется, но в будущем может быть)  

Либо можно просто так:
- docker-compose up postgres

## Разработка на клиенте
1) npm run build
2) npm run start  

## Разработка на сервере
1) npm run build
2) npm run ssr-start

# Об игре

## Поддержка браузерами
- Chrome 40+ (основная платформа)
- Edge 79+
- Safari 10+
- Opera 27+

PS. Firefox не поддерживается, в первую очередь из за плохой поддержки `nonce` (требовается для нормальной работы инлайновых стилей Material UI в связи с Content Security Policy)

## Название игры
Последний практикант

## Концепция
Типа динозаврик гугл (но не совсем), вместо динозаврика студент яндекс практикума. Он будет непрерывно бежать по разным локациям (каждая локация символизирует спринт), на локациях будут встречаться препятствия (баги всякие - можно представить в виде жуков всяких, практика\задания - можно представить в виде компьютеров с иконками, ревьюэры - можно представить в виде злобного человечка и прочее). Препятствия можно перепрыгнуть, пригнуться, разрушить при помощи выстрела (в виде оружия можно представить клаву, клава будет стрелять лампочками - олицетворяют идеи). Запас патронов ограничен (восстанавливается со временем), т.е. например делаем 3 выстрела, потом нужно подождать, по прошествии определенного времени, можно будет опять стрелять. Ограниченный запас патронов будет символизировать степень нашей усталости. Препятствия в виде ревьюэров можно уничтожить только при помощи патронов знаний (подобные препятствия будут встречаться не так часто, как остальные, поэтому желательно расходовать патроны с умом). Количество жизней ограничено 3, они уменьшаются при столкновении с препятствием, восстанавливаются с каждым уровнем (в новый спринт с новыми силами).  

После окончания основных уровней, связанных с практикумом локация будет одна - будет символизировать жизненный путь после практикума. Препятствиями могут быть различные собеседования (в разные компании, можно представить типа человечками с логотипами гугла, эйпл и прочие), изучение новых стеков технологий (типа ящички с лого стеков), повторение и углубление в старые и прочее.  

Задача - продержаться как можно дольше.  

## Управление
Управление на стр. самой игры - при помощи клавы (движение на кн. вверх\вниз - w\s, выстрел - пробел). Управление на прочих страницах мышкой.

## Условия
- жизней - 3
- патронов (идей) - 3 (восстанавливаются со временем)
- время - бесконечно на уровень
- очки - как таковых нет
- победителя как такого нет, есть места в таблице с общей статистикой, считается время, чем дольше продержался - тем лучше
- выбор персонажа не предполагается

## Дизайн.
**Для самой игры**:
- Герой - фигурка Рембо (только вместо оружия клава)
- Локации - всякие джунгли, лес или еще что (локации должны символизировать различные спринты, но можно не париться и сделать их более менее одинаковыми, различия будут в деталях - скины препятствий и т.д.)

**Для остальных стр**:
- Все делаем максимально просто. На главной стр. (разводящая стр., где будет располагаться меню) будет красивый фон с изображением. Само меню будет на полупрозрачной подложке. Остальные стр. просто на темном фоне, без изображения. Цвет рамок и текста - светлый.

**Ссылки на фигму**:
- https://www.figma.com/file/F777YBFGZuKrKDihT2QG2e/LastPracticant

# Примерная структура папок
```
| -- client
    | -- core
        | -- api - API для работы с бэком и его конфиги
        | -- components - корневые компоненты (header и т.д.) и их логика
        | -- HOCs - хоки приложения
        | -- hooks - кастомные хуки
        | -- context - корневые контексты (авторизация, настройки)
        | -- store - redux и его инфраструктура
            | -- actions
            | -- reducers
            | -- selectors
            | -- store.ts
            | -- store.types.ts
    | -- shared
        | -- components - общие переиспользуемые компоненты (инпуты и т.д.) и их логика
            | -- MyPageComponent - директория с компонентом страницы
                | -- components - директория с дочерними компонентами
                    | -- ChildComponent - дочерний компонент
                    | -- index.ts - для экспорта из `components`
                | -- types - директория с интерфейсами типизации компонента, либо MyPageComponent.types.ts
                | -- MyPageComponent.tsx - компонент
                | -- MyPageComponent.scss - стили компонента
                | -- index.ts - для экспорта из `MyPageComponent`
            | -- index.ts - для экспорта из `components`
        | -- utils - вспомогательные функции
        | -- styles - общие стили
    | -- pages - компоненты страницы
    | -- routing - роутинг приложения
    | -- App.css
    | -- App.tsx
| -- server
    | -- api - BFF
    | -- middlewares
    | -- routing - роутинг сервера
    | -- store - инфраструктура redux для ssr
    | -- types - типизация для сервера
    | -- server.utils.ts - утилиты сервера
    | -- start.ts - настройки и запуск сервера
| -- mocks - моковые данные для тестов
```
**Все сущности (компоненты, интерфейсы, контексты, провайдеры) пишем в отдельных файлах.**

**Чтоб не получалась одна гигантская портянка.**

**Исключение могут составлять только очень маленькие вещи. Которые помещаются на один экран без скрола.**

**`index.ts` кладем на уровне компонента если нужен**

# Именования

## Интерфейсы

-   Интерфейсы пишем **без** буквы `I`
-   В конце пропсов добавляем постфикс `Props`. Например: `MyComponentProps`

## Компоненты

-   Компоненты и директории компонентов называем с большой буквы (PascalCase). Например: `MyComponent`
-   Компоненты определяются через стрелочные функции
-   Ключевое слово `export` пишется рядом с функцией компонента **без (`export default`)**
-   Пропсы типизируютя через дженерик типа функционального компонента
-   Логика в компоненте находится выше разметки

**Пример**

```
import { FC } from 'react';
import { MyComponentProps } from './MyComponentProps.model.ts';

export const MyComponent:FC<MyComponentProps> = (props) => {

  const myMethod = () => {};

  return <div>component content</div>
}
```
# Правила оформления кода на React (для ознакомления)
https://netology-university.bitbucket.io/codestyle/react/

# Чистый код (следует воспринимать как рекомендацию)

Несколько основных правил которых стоит придерживаться при написании кода. Они позволя стандартизировать код, сделать его более понятным и читаемым для всех.

## Содержание и размер файлов и сущностей

В идеале каждый файл должен содержать только одну сущность (интерфейс, константу, компонент и т.д.)

Исключения могут составлять связанные небольшие сущности. Например компонент и интерфейс его пропсов. Если интерфейс небольшой.

Отдельные сущности не должны привышать следующих размеров:

-   Компонент - до 250 - 300 строчек
-   Функция - до 10 - 25 строчек

В противном случае их надо рефакторить разбивать на более мелкие сущности.

Если разметка компонента разрастается, то логические выражения надо вынасить в константы выше используя useMemo.

# Прочие договоренности
- в качестве инструмента слияния используем - **rebase**, перед влитием необходимо делать сквош коммитов (можно через git rebase -i)
- используем по максимуму, где это возможно - **функциональные компоненты**
- при **именовании веток**, ориентируемся на заголовок задачи, на ее номер, например: для задачи `LP-234 Заголовок задачи` ветка будет такой `LP-234`
- комментарии к коммитам должны начинаться с номера задачи, например `LP-234 текст комментария`
- **новый таск - новая ветка**, если таск большой - делим на сабтаски со своими ветками
- **стили**: можно использовать css in js, post css, css переменные
- **ревью** - 2 человека проводят, 1 approve для мержа, Reviewers - члены команды, Assigneers - все (включая наставника)
- все **реквесты направляются** в dev, из dev реквест делается в main
- **резолвить в мерж-реквесте** может только автор топика
- для **запросов** использовать [Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API)
